assert(1)# comments are working
# also at line beginning
# assert(0)

print("TEST: assignment")
n=1
assert_equal(n, 1)
print("test successful")

print("TEST: arithmetics")
assert_equal(1+1, 2)
assert_equal(2*2, 4)
print("test successful")

print("TEST: adding strings")
assert_equal("John"+" "+"Smith", "John Smith")
print("test successful")

print("TEST: basic functions")
add=(a, b)->a+b
assert_equal(add(2, 5), 7)
double=n->n*2
assert_equal(double(5), 10)
print("test successful")

test=(name, assertion)->{
    print("TEST: "+name)
    assertion()
    print("test successful")}
test("test helper function", ->assert(1))

test("stack optimisations", ->{
    a=1
    b=5
    c=8
    assert_equal(a+a+b+b+a+c+b, 26)
})

assert_error=o->{
    assert(o.error)
    o.handled=1
}

test("string functions", ->{
    assert_equal(substring("John", 2, 4), "hn")
    assert_error(substring("John", -1, 4))
    assert_error(substring("John", 0, 5))
    assert_error(substring("John", "John", 4))
    assert_error(substring("John", 0, "John"))

    assert_equal(string_length("John"), 4)
    assert_error(string_length(1))

    assert_equal(to_character(64), "@")
    assert_error(to_character("@"))
    
    assert_equal(from_character("@"), 64)
    assert_error(from_character(64))
})

test("format function", ->{
    assert_equal(format("name: {}, surname: {}", "John", "Doe"), "name: John, surname: Doe")

    # not enough arguments provided to the format function should cause an error
    assert_error(format("name: {}, surname: {}", "John"))
    assert_error(format("name: {}, surname: {}"))

    # incorrectly written braces
    assert_equal(format("name: {, surname: {}", "John", "Doe"), "name: {, surname: John")
    assert_equal(format("name: {, surname: }", "John", "Doe"), "name: {, surname: }")
    assert_equal(format("name: {}, surname: {", "John", "Doe"), "name: John, surname: {")

    # escaping
    assert_equal(format("\{}", 1), "{}")
    assert_equal(format("\\{}", 1), "\1")

    # error when first argument is not a string
    assert_error(format(1, 4))
})

test("type casting", ->{
    five=5
    text="5"
    assert_equal(to_int(text), five)
    assert_equal(to_string(five), text)
    assert_equal(cast(text, types.int), five)
    assert_equal(cast(five, types.string), text)
})

test("closures", ->{
    # a and one are variables used by closure returned by adder
    adder=a->{
        one=1
        x->(a+x)*one
    }
    add_two=adder(2)
    assert_equal(add_two(5), 7)
})

test("operators", ->{
    assert_equal(2*8, 16)
    assert_equal(10/2, 5)
    assert_equal(7//2, 3)
    assert_equal(7%2, 1)
    assert_error(2.5%2)
    assert_error(2.5%2)
})

test("coroutines", ->{
    c=coroutine(b->{
        a=yield()
        yield(b+a)
    }, 10)
    c()
    assert_equal(c(2), 12)
    counter=1
    coroutine(->{
        yield(1)
        yield(2)
        yield(3)
    }) `#` x->{
        assert_equal(x, counter)
        counter+=1
    }
})

test("question mark", ->{
    f=x->{
        if(x){
            format("{}")!?
        }
        10
    }
    assert_error(f(1))
})

test("garbage collection", ->{
    destroy_calls=0
    circular_reference=->{
        tab=[
            number=1
            destroy=self->destroy_calls+=self.number
        ]
        tab.self=tab
        tab
    }
    loop=(times ,f)->{
        f()
        if(times>1){
            loop(times-1, f)
        } 
    }
    loop(100, circular_reference)
    collect_garbage()
    assert_equal(destroy_calls, 100)
})