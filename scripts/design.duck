o=[1, 2, 3]

# metatable - not really
o.set_metatable(
    o.get_metatable + [
        "+" = (self, b)->map(self, (e)->e+b)
        "set" = -> Error("Read-only table.")
    ]
)

# magic indexes
o["+"] = (self, b)->map(self, (e)->e+b)
o["set"] = -> Error("Read-only table.")

# wrapping base types
degree = (num)->{
    d=wrap(num)
    d["+"] = (self, b) -> {
        result=self.value+b
        if(result>360){
            result-360
        } else {
            result
        }
    }
    d
}

# magic functions
yield(0)
coroutine(f)

arr=[1, 2, 3, name="John"]

f=(a, b)->{
    c=a-b
    (a+b)/c
}

# return

fib=n->{
    if(n==0) 0.
    elif(n==1) 1.
    fib(n-1)+fib(n-2)
}
fib=n->{
    if(n==0) 0 end
    elif(n==1) 1 end
    fib(n-1)+fib(n-2)
}
fib=n->{
    if(n==0) 0 return
    elif(n==1) 1 return
    fib(n-1)+fib(n-2)
}
fib=n->{
    if(n==0) 0!
    elif(n==1) 1!
    fib(n-1)+fib(n-2)
}
fib=n->{
    if(n==0) 0 |
    elif(n==1) 1 |
    fib(n-1)+fib(n-2)
}

fib=n->{
    if(n==0) 0 <-
    elif(n==1) 1 <-
    fib(n-1)+fib(n-2)
}

call=(self, arguments){
    if(typeof(self)==function){
        self(arguments)
    } elif(table.call!=null){
        table.call(arguments)
    } else {
        error("Can' index object "+self)
    }
}

get_override=(self, key)->{
    if(key=="full_name"){
        self.name+self.surname
    } else {
        get_native(self, key)
    }
}

call_override(self, arguments)-{
    self.call_count++
    native_call(self.contained_function, arguments)
}

table.get=(table, key)->{
    if(table.get!=null){
        table.get(table, key)
    } else {
        get_native(table, key)
    }
}