assert(1)# comments are working
# also at line begining
# assert(0)

print("TEST: assignment")
n=1
assert(n==1)
print("test successful")

print("TEST: arithmetics")
assert(1+1==2)
assert((2*2)==4)
print("test successful")

print("TEST: adding strings")
assert(("John"+" "+"Smith")=="John Smith")
print("test successful")

print("TEST: basic functions")
add=(a, b)->a+b
assert(add(2, 5)==7)
double=n->n*2
assert(double(5)==10)
print("test successful")

test=(name, assertion)->{
    print("TEST: "+name)
    assertion()
    print("test successful")}
test("test helper function", ->assert(1))

test("stack optimisations", ->{
    a=1
    b=5
    c=8
    assert(a+a+b+b+a+c+b==26)
})

global.assert_error=o->{
    assert(o.error)
    o.handled=1
}

test("string functions", ->{
    assert(substring("John", 2, 4)=="hn")
    assert_error(substring("John", -1, 4))
    assert_error(substring("John", 0, 5))
    assert_error(substring("John", "John", 4))
    assert_error(substring("John", 0, "John"))

    assert(string_length("John")==4)
    assert_error(string_length(1))

    assert(to_character(64)=="@")
    assert_error(to_character("@"))
    
    assert(from_character("@")==64)
    assert_error(from_character(64))
})

test("format function", ->{
    assert(format("name: {}, surname: {}", "John", "Doe")=="name: John, surname: Doe")

    # not enough arguments provided to the format function should cause an error
    assert_error(format("name: {}, surname: {}", "John"))
    assert_error(format("name: {}, surname: {}"))

    # incorrectly written braces
    assert(format("name: {, surname: {}", "John", "Doe")=="name: {, surname: John")
    assert(format("name: {, surname: }", "John", "Doe")=="name: {, surname: }")
    assert(format("name: {}, surname: {", "John", "Doe")=="name: John, surname: {")

    # escaping
    assert(format("\{}", 1)=="{}")
    assert(format("\\{}", 1)=="\1")

    # error when first argument is not a string
    assert_error(format(1, 4))
})

test("type casting", ->{
    five=5
    text="5"
    assert(int(text)==five)
    assert(string(five)==text)
    assert(cast(text, 'int)==five)
    assert(cast(five, 'string)==text)
})

test("closures", ->{
    # a and one are variables used by closure returned by adder
    adder=a->{
        one=1
        x->(a+x)*one
    }
    add_two=adder(2)
    assert(add_two(5)==7)
})

test("operators", ->{
    assert(2*8==16)
    assert(10/2==5)
    assert(7//2==3)
    assert(7%2==1)
    assert_error(2.5%2)
    assert_error(2.5%2)
})

test("coroutines", ->{
    c=coroutine(b->{
        a=yield()
        yield(b+a)
    }, 10)
    c()
    assert(c(2)==12)
    counter=1
    coroutine(->{
        yield(1)
        yield(2)
        yield(3)
    }) `#` x->{
        assert(x==counter)
        counter+=1
    }
})

test("question mark", ->{
    f=x->{
        if(x){
            format("{}")?
        }
        10
    }
    assert_error(f(1))
})

test("garbage collection", ->{
    destroy_calls=0
    circular_reference=->{
        tab=[
            number=1
            destroy=self->destroy_calls+=self.number
        ]
        tab.self=tab
        tab
    }
    loop=(times ,f)->{
        f()
        if(times>1){
            loop(times-1, f)
        } 
    }
    loop(100, circular_reference)
    collect_garbage()
    assert(destroy_calls==100)
})